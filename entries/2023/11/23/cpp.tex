% % % mainfile: ../../../../master.tex
\subsection{C++ Types and Data Structures}
\label{task:20231123_cpp}

\subsubsection{Aliases}

Traditionally, we use \textbf{\texttt{typedef}} for synonym for another type:
\begin{lstlisting}[language=C++]
typedef double wages; // wages is a synonym for double 
typedef wages base, *p; // base is a synonym for double, p for double*
\end{lstlisting}


The new standard introduced a second way to define \textbf{alias declaration} type alias:
\begin{lstlisting}[language=C++]
using SI = Sales_item; // SI is a synonym for Sales_item
\end{lstlisting}

It is also possible to declare "pointer to" alias:
\begin{lstlisting}[language=C++]
typedef char *pstring; 
const pstring cstr = 0; // equivalent to char *const cstr = 0; 
const pstring *ps; // equivalent to const char *ps;
\end{lstlisting}

\subsubsection{\texttt{auto} Type Specifier}

We can let the compiler deduce the type from the initializer for us by using the \texttt{auto} type specifier:
\begin{lstlisting}[language=C++]
// the type of item is deduced from the type of the result of adding val1 and val2 
auto item = val1 + val2; // item initialized to the result of val1+val2
\end{lstlisting}

The initializaer for all the variables muxt have types that are consistent with each other:
\begin{lstlisting}[language=C++]
auto i = 0, *p = &i; // ok: i is int and p is a pointer to int 
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi
\end{lstlisting}

\texttt{auto} ignores top-level \texttt{const}s, and only low-level initializer are usually kept:
\begin{lstlisting}[language=C++]
auto i = 0, *p = &i; // ok: i is int and p is a pointer to int 
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi
\end{lstlisting}